<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Presentation 2&mdash; Class 5828 &mdash; Fall 2015</title>

		<meta name="description" content="Presention for class 5828">
		<meta name="author" content="Yun Zhou and Tiantian Xie">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/sky.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">


				<section>
					<h2>XML</h2>
					<h4>Presentation 2&mdash; Class 5828&mdash; Fall 2015</h4>
        <p> Yun Zhou and Tiantian Xie</p>
				</section>


			<section>
				<h2>XML - Overview</h2>
<ul>
				<p>XML stands for <strong>Extensible Markup Language</strong>. It is a text-based markup language derived from Standard Generalized Markup Language (SGML).</p>
				<p>XML tags identify the data and are used to store and organize the data, rather than specifying how to display it like HTML tags, which are used to display the data. XML is not going to replace HTML in the near future, but it introduces new possibilities by adopting many successful features of HTML.</p>
</ul>
			</section>

			<section>

				<h2>XML - Benefits</h2>
<ul>
				<p>There are three important characteristics of XML that make it useful in a variety of systems and solutions:</p>
				<li>XML is extensible: XML allows you to create your own self-descriptive tags, or language, that suits your application.</li>
				<li>XML carries the data, does not present it: XML allows you to store the data irrespective of how it will be presented.</li>
				<li>XML is a public standard: XML was developed by an organization called the World Wide Web Consortium (W3C) and is available as an open standard.</li>
</ul>
			</section>



			<section>

				<h2>XML - USAGE</h2>
				<p>A short list of XML usage says it all:</p>

<ul>				<li>XML can work behind the scene to simplify the creation of HTML documents for large web sites.</li>
				<li>XML can be used to exchange the information between organizations and systems.</li>
				<li>XML can be used for offloading and reloading of databases.</li>
				<li>XML can be used to store and arrange the data, which can customize your data handling needs.</li>
				<li>XML can easily be merged with style sheets to create almost any desired output.</li>
				<li>Virtually, any type of data can be expressed as an XML document.</li>

</ul>
			</section>


			<section>
		
				<h2>XML - Syntax I</h2>
				<p>Following is a complete XML document:</p>
				<pre><code data-trim contenteditable>
					<?xml version="1.0"?>
					<contact-info>
					<name>Sophy Zhou</name>
					<company>University of Colorado Boulder</company>
					<phone>(011) 123-4567</phone>
					</contact-info>
				</code></pre>

			</section>


			<section>
		
				<h2>XML - Syntax II</h2>
				<p>A XML document generally consists of two parts: </p>
				<ul>
				<li><strong>Document Prolog Section</strong>: The document prolog comes at the top of the document, before the root element. This section contains:</li>
					<ul>			
						<li>XML declaration</li>
						<li>Document type declaration</li>
					<ul>

				<li><strong>Document Elements Section</strong>:Document Elements are the building blocks of XML. These divide the document into a hierarchy of sections, each serving a specific purpose. You can separate a document into multiple sections so that they can be rendered differently, or used by a search engine. The elements can be containers, with a combination of text and other elements.</li>
				</ul>

			</section>

			<section>
		
				<h2>XML - Syntax III</h2>
				<ul>
				<p>The following diagram depicts the syntax rules to write different types of markup and text in an XML document.</p>
				</ul>

			</section>

			<section>
		
				<h2>XML - Declaration I</h2>
				<ul>
				<p>The XML document can optionally have an XML declaration. It is written as below:</p>
				<pre><code data-trim contenteditable>
				<?xml
 				  version="version_number"
   				  encoding="encoding_declaration"
	        		  standalone="standalone_status"
                                ?>
				</code></pre>
				<p>Where <em>version</em> is the XML version and <em>encoding</em> specifies the character encoding used in the document.</p>

				<p><strong>Syntax Rules for XML declaration</strong></p>
				<li>The XML declaration is case sensitive.</li>
				<li>If document contains XML declaration, then it strictly needs to be the first statement of the XML document.</li>
				<li>The XML declaration strictly needs be the first statement in the XML document.</li>
				<li>An HTTP protocol can override the value of encoding that you put in the XML declaration.</li>
				</ul>

			</section>


			<section>
		
				<h2>XML - Declaration II</h2>
				<ul>
				<p>Following are few examples of XML declarations:</p>
				<li>XML declaration with no parameters:</li>
		   			<pre><code data-trim contenteditable>
					<?xml >
					</code></pre>
				<li>XML declaration with version definition:</li>
					<pre><code data-trim contenteditable>
					<?xml version="1.0">
					</code></pre>
				<li>XML declaration with all parameters defined:</li>
					<pre><code data-trim contenteditable>
					<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
					</code></pre>
				<li>XML declaration with all parameters defined in single quotes:</li>
					<pre><code data-trim contenteditable>
					<?xml version='1.0' encoding='iso-8859-1' standalone='no' ?>
					</code></pre>

				</ul>

			</section>


			<section>		
				<h2>XML - Tags I</h2>
				<ul>
				<p><strong>Start Tag</strong>: The beginning of every non-empty XML element is marked by a start-tag. An example of start-tag is:</p>
				<pre><code data-trim contenteditable>
				<address>
				</code></pre>
				<p><strong>End Tag</strong>: Every element that has a start tag should end with an end-tag. An example of end-tag is:</P>
				<pre><code data-trim contenteditable>
				</address>
				</code></pre>
				<p><strong>Empty Tag</strong>: The text that appears between start-tag and end-tag is called content. An element which has no content is termed as empty. An empty element can be represented in two ways as below:</p>
				<li>A start-tag immediately followed by an end-tag as shown below:</li>
				<pre><code data-trim contenteditable>
				<hr></hr>
				</code></pre>
				<li>A complete empty-element tag is as shown below:</li>
				<pre><code data-trim contenteditable>
				<hr />
				</code></pre>
				<p>Empty-element tags may be used for any element which has no content.</p>
				</ul>
			</section>

			<section>		
				<h2>XML - Tags II</h2>
				<ul>
				<p>XML Tags Rules</p>
				<li>Rule 1: XML tags are case-sensitive. </li>
				<li>Rule 2: XML tags must be closed in an appropriate order, i.e., an XML tag opened inside another element must be closed before the outer element is closed.</li>
				</ul>
			</section>

			<section>		
				<h2>XML - Elements I</h2>
				<ul>
				<p>Following is the syntax to write an XML element:</p>
				<pre><code data-trim contenteditable>
				<element-name attribute1 attribute2>
				....content
				</element-name>
				</code></pre>
				<p>where</p>
				  <ul>
				     <li><strong>element-name<strong> is the name of the element. The name its case in the start and end tags must match.</li>
				     <li>attribute1, attribute2 are attributes of the element separated by white spaces. An attribute defines a property of the element. It associates a name with a value, which is a string of characters. An attribute is written as:</li>
				           <pre><code data-trim contenteditable>
                                           name = "value"
				           </code></pre>
				    <p><em>name</em> is followed by an = sign and a string value inside double(" ") or single(' ') quotes.</p>
				  </ul>
				</ul>
			</section>

			<section>		
				<h2>XML - Elements II</h2>
				<ul>
				<p><strong>Nesting of elements</strong>: An XML-element can contain multiple XML-elements as its children, but the children elements must not overlap. i.e., an end tag of an element must have the same name as that of the most recent unmatched start tag.
				<pre><code data-trim contenteditable>
				<?xml version="1.0"?>
				<contact-info>
				<company>University of Colorado Boulder</company>
				<contact-info>
				</code></pre>

				<p><strong>Root element</strong>: An XML document can have only one root element. 
				</ul>
			</section>


			<section>		
				<h2>XML - Elements III</h2>
				<ul>
				<p>Following rules are required to be followed for XML elements:</p>
				<li>An element name can contain any alphanumeric characters. The only punctuation mark allowed in names are the hyphen (-), under-score (_) and period (.).</li>
				<li>Names are case sensitive. For example, Address, address, and ADDRESS are different names.</li>
				<li>Start and end tags of an element must be identical.</li>
				<li>An element, which is a container, can contain text or elements as seen in the above example.</li>
				</ul>
			</section>


			<section>		
				<h2>XML - Attributes</h2>
				<ul>
				<p>An XML attribute has following syntax:</p>
				<pre><code data-trim contenteditable>
				<element-name attribute1 attribute2 >
				....content..
				< /element-name>
				</code></pre>
				<p>where attribute1 and attribute2 has the following form:</p>
				<pre><code data-trim contenteditable>
                                name = "value"
				</code></pre>
				<p>value has to be in double (" ") or single (' ') quotes. Here, attribute1 and attribute2 are unique attribute labels.</p>
				<p>Following are the rules that need to be followed for attributes:</p>
				<li>An attribute name must not appear more than once in the same start-tag or empty-element tag.</li>
				<li>An attribute must be declared in the Document Type Definition (DTD) using an Attribute-List Declaration.</li>
				<li>Attribute values must not contain direct or indirect entity references to external entities.</li>
				<li>The replacement text of any entity referred to directly or indirectly in an attribute value must not contain either less than sign <</li>
				</ul>
			</section>


			<section>		
				<h2>XML Attributes – Example</h2>
				<ul>
				<p>Attributes are used to add a unique label to an element, place the label in a category, add a Boolean flag, or otherwise associate it with some string of data. Following example demonstrates the use of attributes:</p>
				<pre><code data-trim contenteditable>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE garden [
   <!ELEMENT garden (plants)*>
   <!ELEMENT plants (#PCDATA)>
   <!ATTLIST plants category CDATA #REQUIRED>
]>
<garden>
   <plants category="flowers" />
   <plants category="shrubs">
   </plants>
</garden>
				</code></pre>

				<p>Attributes are used to distinguish among elements of the same name. When you do not want to create a new element for every situation. Hence, use of an attribute can add a little more detail in differentiating two or more similar elements.</p>
				<p>In the above example, we have categorized the plants by including attribute category and assigning different values to each of the elements. Hence we have two categories of plants, one flowers and other color. Hence we have two plant elements with different attributes.</p>
				</ul>
			</section>



				<section>
					<h2>XML - Comments</h2>
					<p>The comments are added as notes or lines for understanding the purpose of an XML code.</p>
					<pre><code data-trim contenteditable> Syntax :<!----Your comment----></code></pre>
					<p>Rules:</p>
					<ul>
  				<li>Comments cannot appear before XML declaration.</li>
					<li>Comments may appear anywhere in a document.</li>
					<li>Comments must not appear within attribute values.</li>
					<li>Comments cannot be nested inside the other comments.</li>
					</ul>
				</section>

				<section>
				<h2>XML - CDATA Sections</h2>
				<p>CDATA are defined as blocks of text that are not parsed by the parser, but are otherwise recognized as markup.</p>
				<pre> <code data-trim contenteditable>
						<![CDATA[<message> XML </message>]] >
				</code></pre>
				<p>In the above syntax, everthing between <message> and </message> is treated as character data and not as markup.</p>
  			        </section>

				<section>
					<h2>XML - Character Entities</h2>
					<p>Character Entities are used to display special characters.</p>
					<table style="width:50%">
  					<tr>
    						<td>Ampersande</td>
    						<td>& amp</td>
  					</tr>
  					<tr>
    						<td>Single quote</td>
    						<td>& apôs</td>
  					</tr>
  					<tr>
    						<td>Greater than</td>
    						<td>& gt</td>
  						</tr>
  						<tr>
    						<td>Less than</td>
    						<td>& lt</td>
  							</tr>
  							<tr>
    							<td>Double quote</td>
    							<td>& quot</td>
  								</tr>
									</table>
								</section>


				<section>
					<h2>XML - White Spaces(1)</h2>
					<pre><p>Whitespace is a collection of spaces, tabs, and newlines. They are generally used to make a document more readable.</p></pre>
					<p>XML document contain two types of white spaces:
						<ul>
						<li>
						(a) Significant Whitespace  </li><br>
						<li>
						(b) Insignificant Whitespace. Both are explained below with examples.</p>
					</li>
				</ul>
				</section>

				<section>
		<h2>XML - White Spaces(2)</h2>
		<pre>
			<code data-trim contenteditable>
		<name>TanmayPatil</name> and <name>Tanmay Patil</name>
	</code>
		</pre>
		<p>The above two elements are different because of the space between <strong>Tanmay</strong> and <strong>Patil</strong>. Any program reading this element in an XML file is obliged to maintain the distinction.</p>
		</section>

		<section>
			<h2>XML - White Spaces(3)</h2>
<p>Insignificant whitespace means the space where only element content is allowed. For example:</p>
<pre>
	<code data-trim contenteditable><address.category="residence"> and <address....category="..residence"></code></pre>
<p>These two examples are same. Here, the space is represented by dots (.).
	The space between address and category is insignificant.</p>
		</section>

		<section>
			<h2>XML - White Spaces(4)</h2>
			<p>A special attribute named xml:space may be attached to an element. This indicates that whitespace should not be removed for that element by the application. You can set this attribute to default or preserve as shown in the example below:</p>
			<pre>
				<code data-trim contenteditable><!ATTLIST address  xml:space (default|preserve) 'preserve'></code>
			</pre>
		</section>

		<section>
			<h2>XML - Processing(1)</h2>
			<pre>
				<p>"Processing instructions (PIs) allow documents to contain instructions for applications. PIs are not part of the character data of the document, but MUST be passed through to the application.</p>
			</pre>
			<pre>
			<code data-trim contenteditable>Syntax:<?target instructions?></code>
		</pre>
			<ul>
				<li><strong>target</strong> - identifies the application to which the instruction is directed.<br>
			</li>
		</ul>
		<ul>
				<li><strong>instruction</strong> - it is a character that describes the information for the application to process.</li>
</ul>
			</p>

			</p>

		</section>
<section>
	<h2>XML - Processing(2)</h2>
	<pre>
	<code data-trim contenteditable><?xml-stylesheet href="tutorialspointstyle.css" type="text/css"?></code>
</pre>
	<pre>Here, the target is xml-stylesheet. href="tutorialspointstyle.css" and type="text/css" are data or instructions that the target application will use at the time of processing the given XML document.

In this case, a browser recognizes the target by indicating that the XML should be transformed before being shown; the first attribute states that the type of the transform is XSL and the second attribute points to its location.</pre>
</section>



<section>
	<h2>XML - Processing(3)</h2>
	<p>A PI can contain any data except the combination ?>, which is interpreted as the closing delimiter. Here are two examples of valid PIs:</p>
<pre>
<code data-trim contenteditable>

	<?welcome to pg=10 of tutorials point?><br>

	<?welcome?>
</code>
</pre>
</section>

<section>
	<h2>XML-Encoding(1)</h2>
	<pre>
Encoding is the process of converting unicode characters into their equivalent binary representation. When the XML processor reads an XML document, it encodes the document depending on the type of encoding.
	</pre>
	<p style="text-align:left">
		Encoding Types:
		<ul>
		<li>
			UTF-8
		</li>
		<li>
			UTF-16
		</li>
	</ul>
	</p>
	<p style="font-size:60%">
		UTF stands for UCS Transformation Format, and UCS itself means Universal Character Set. The number 8 or 16 refers to the number of bits used to represent a character. They are either 8(one byte) or 16(two bytes). For the documents without encoding information, UTF-8 is set by default.
	</p>
</section>

<section>
		<h2>XML-Encoding(2)</h2>
		<p>
			The syntax for UTF-8 encoding is below:
			<pre>
			<code data-trim contentEditable>
				<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
			</code>
		</pre>
		</p>
		<p>
			The syntax for UTF-16 encoding is below:
			<pre>
			<code data-trim contentEditable>
				<?xml version="1.0" encoding="UTF-16" standalone="no" ?>
			</code>
		</pre>
		</p>
</section>

<section>
	<h2>XML-Encoding(3)</h2>
	<pre>
		<code data-trim contentEditable>
			<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<contact-info>
   <name>Amy</name>
   <company>University of Colorado, Boulder</company>
   <phone>(011) 123-4567</phone>
</contact-info>
		</code>
	</pre>
</section>

<section>
	<h2>XML-Validation(1)</h2>
	<pre>
Validation is a process by which an XML document is validated. An XML document is said to be valid if its contents match with the elements, attributes and associated document type declaration(DTD), and if the document complies with the constraints expressed in it. Validation is dealt in two ways by the XML parser. They are:
<li>Well-formed XML document
</li>
<li>Valid XML document
</li>
	</pre>
</section>

<section>
	<h2>XML-Validation(2)</h2>
	<p>
		An XML document is said to be <strong>well-formed</strong> if it adheres to the following rules:
	</p>
	<pre>

<li>Non DTD XML files must use the predefined character entities for <strong>amp</strong>(&),<strong> apos</strong>(single quote), <strong>gt</strong>(>), <strong>lt</strong>(<), <strong>quot</strong>(double quote).</li>
<li>It must follow the ordering of the tag. i.e., the inner tag must be closed before closing the outer tag.</li>
<li>Each of its opening tags must have a closing tag or it must be a self ending tag.</li>
<li>It must have only one attribute in a start tag, which needs to be quoted.</li>
<li><strong>amp</strong>(&), <strong>apos</strong>(single quote), <strong>gt</strong>(>), <strong>lt</strong>(<), <strong>quot</strong>(double quote) entities other than these must be declared.</li>


</section>

<section>
	<h2>XML-Validation(3)</h2>
	<pre>
		<code data-trim contenteditable>
			<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE address
[
   <!ELEMENT address (name,company,phone)>
   <!ELEMENT name (#PCDATA)>
   <!ELEMENT company (#PCDATA)>
   <!ELEMENT phone (#PCDATA)>
]>
<address>
   <name> Amy</name>
   <company>University of colorado, Boulder</company>
   <phone>(011) 123-4567</phone>
</address>
		</code>
	</pre>

<pre>
Above example is said to be well-formed as:
(1)It defines the type of document. Here, the document type is element type.
(2)It includes a root element named as address.
(3)Each of the child elements among name, company and phone is enclosed in its self explanatory tag.
(4)Order of the tags is maintained.
</pre>
</section>

<section>
	<h2>XML-Validation(4)</h2>
	<p>If an XML document is well-formed and has an associated Document Type Declaration (DTD), then it is said to be a valid XML document. </p>
</section>

<section>
	<h2>XML-DTD(1)</h2>
	<pre>
The purpose of a DTD is to define the structure of an XML document. It defines the structure with a list of legal elements:
	</pre>
	<pre>
<code data-trim contenteditable>
<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE note[<!ELEMENT note (to,from,heading,body)>
<!ELEMENT to (#PCDATA)>
<!ELEMENT from (#PCDATA)>
<!ELEMENT heading (#PCDATA)>
<!ELEMENT body (#PCDATA)>
]>
</code>
	</pre>

</section>

<section>
	<h2>XML-DTD(2)</h2>
<p>The DTD in the above page is interpreted like this:</p>
<ul>
	<li>!DOCTYPE note defines that the root element of the document is note</li>
	<li>!ELEMENT note defines that the note element must contain the elements: "to, from, heading, body"</li>
	<li>!ELEMENT to defines the to element to be of type "#PCDATA"</li>
	<li>!ELEMENT from defines the from element to be of type "#PCDATA"</li>
	<li>!ELEMENT heading defines the heading element to be of type "#PCDATA"</li>
	<li>!ELEMENT body defines the body element to be of type "#PCDATA"</li>
</ul>
</section>

<section>
<h2>XML-DTD(3)</h2>
<p>Rules:</p>
<ul>
<li>The document type declaration must appear at the start of the document (preceded only by the XML header) — it is not permitted anywhere else within the document.</li>
<li>Similar to the DOCTYPE declaration, the element declarations must start with an exclamation mark.</li>
<li>The Name in the document type declaration must match the element type of the root element.</li>
</ul>
</section>

<section>
<h2>XML-DTD(4)</h2>
<pre>In external DTD elements are declared outside the XML file. They are accessed by specifying the system attributes which may be either the legal .dtd file or a valid URL. To refer it as external DTD, standalone attribute in the XML declaration must be set as no. This means, declaration includes information from the external source.</pre>
<pre>
<code data-trim contenteditable>
	<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<!DOCTYPE note SYSTEM "note.dtd">
<note>
<to>Amy</to>
<from>Elsa</from>
<heading>Reminder</heading>
<body>Don't forget the due day</body>
</note>
</code>
</pre>

</section>

<section>
<h2>XML-Schemas(1)</h2>
<pre>XML schema is used to describe and validate the structure and the content of XML data</pre>
<p>
<strong>Simple Type</strong> - Simple type element is used only in the context of the text. Some of predefined simple types are: xs:integer, xs:boolean, xs:string, xs:date. For example:</p>
<pre>
	<code data-trim contenteditable>
		<xs:element name="phone_number" type="xs:int" />
	</code>
</pre>
</section>

<section>
<h2>XML-Schemas(2)</h2>
<p><strong>Complex Type</strong> - A complex type is a container for other element definitions. This allows to specify which child elements an element can contain and to provide some structure within the XML documents. </p>
<pre>
	<code data-trim contenteditable>
		<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
<xs:element name="contact">
    <xs:complexType>
        <xs:sequence>
            <xs:element name="name" type="xs:string" />
            <xs:element name="company" type="xs:string" />
            <xs:element name="phone" type="xs:int" />
        </xs:sequence>
    </xs:complexType>
</xs:element>
</xs:schema>
</code>
</pre>
</section>

<section>
<h2>XML-Schemas(3)</h2>
<p><strong>Global Types</strong> - With global type, a single type is defined in document, which can be used by all other references. For example:</p>
<pre>
	<code data-trim contenteditable>
		<xs:element name="AddressType">
    <xs:complexType>
        <xs:sequence>
            <xs:element name="name" type="xs:string" />
	    <xs:element name="company" type="xs:string" />
        </xs:sequence>
    </xs:complexType>
</xs:element>
	</code>
</pre>
<p>Here, we defined a general type <em>name</em> and <em>company</em>.</p>
</section>

<section>
	<h2>XML-Schemas(4)</h2>
	<pre>
		<code data-trim contenteditable>
			<xs:element name="Address1">
    <xs:complexType>
        <xs:sequence>
            <xs:element name="address" type="AddressType" />
	    <xs:element name="phone1" type="xs:int" />
        </xs:sequence>
    </xs:complexType>
</xs:element>
<xs:element name="Address2">
    <xs:complexType>
        <xs:sequence>
            <xs:element name="address" type="AddressType" />
	    <xs:element name="phone2" type="xs:int" />
        </xs:sequence>
    </xs:complexType>
</xs:element>
		</code>
	</pre>
	<p>
Now, we can use <em>name</em> and <em>company</em> without define them twice.
</p>
</section>


				<section>
					<h2>Explanation (3)</h2>
					<pre><code data-trim contenteditable>
function (req, res) {
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.end('Hello World\n');
}
					</code></pre>
					<ul>
						<li>This is the <em>anonymous</em> function passed to <strong>createServer()</strong>.</li>
						<li>Each time the server receives a request
							<ul>
								<li>It invokes this function and passes the HTTP request and response objects</li>
							</ul>
						</li>
						<li>This particular function ignores all input and generates a simple HTTP response.</li>
					</ul>
				</section>

				<section>
					<h2>Explanation (4)</h2>
					<pre><code data-trim contenteditable>
console.log('Server running at http://127.0.0.1:1337/');
					</code></pre>
					<ul>
						<li><strong>console.log()</strong> is the <strong>printf()</strong> of the Javascript world.</li>
					</ul>
				</section>

				<section>
					<h2>Explanation (5)</h2>
					<p>Our program in abstract form</p>
					<pre><code data-trim contenteditable>
1. Get the http module.
2. Create a server; register a function; start a server.
3. Print out a message.
					</code></pre>
					<ul>
						<li>All of this is executed immediately when passed to <strong>node</strong></li>
						<li>If no future work remained, <strong>node</strong> would shut down.</li>
						<li>This particular program, however, will run forever
							<ul>
								<li>because the HTTP server has set up an event to check for new requests on every cycle of the event loop</li>
						</li>
					</ul>
				</section>

				<section>
					<h2>Event Loop?</h2>
					<ul>
						<li>In order to understand Node.js, you need to understand the <em>event loop</em></li>
						<li>Event-based programming is a programming style where the code you write is not in control
							<ul>
								<li>Instead, you write code that says (essentially)<br>"When event x happens, do this"</li>
							</ul>
						</li>
					</ul>
				</section>

				<section>
					<h2>Event Loop (1)</h2>
					<p>The basic structure of all Node.js programs</p>
					<pre><code data-trim contenteditable>
while (there are events to be handled) {
	handle event
}
					</code></pre>
					<p>This is how GUI programs are written.</p>
					<p>"If user click here, do this."</p>
				</section>

				<section>
					<h2>Event Loop (2)</h2>
					<ul>
						<li>Node tries to make it easy to <a href="http://nodejs.org/api/timers.html">add work to the event queue</a></li>
						<li>Libraries like <strong>http</strong> take functions and add them to the queue on your behalf (as we saw with <strong>createServer()</strong>).</li>
						<li>Node also lets you add functions to the event queue for later execution.
							<ul>
								<li>process.nextTick()</li>
								<li>setImmediate()</li>
								<li>setTimeout()</li>
								<li>setInterval()</li>
							</ul>
						</li>
					</ul>
				</section>

				<section>
					<h2>Event Loop (3) &mdash; process.nextTick()</h2>
					<p>A simple example using process.nextTick()</p>
					<pre><code data-trim contenteditable>
console.log("first!");
process.nextTick(function() {
  console.log("third!");
});
console.log("second!");
					</code></pre>
					<ul>
						<li>Our main program is simply a function passed to the event loop</li>
						<li>On the first pass: log(), nextTick(), log()</li>
						<li>On the second pass: log()</li>
						<li>Since there are no more events, the program ends.</li>
					<ul>
				</section>

				<section>
					<h2>Event Loop (4)</h2>
					<ul>
						<li>Our program would behave the same if you replaced process.nextTick() with setImmediate()</li>
						<li>They both schedule a function for the next iteration of the event loop.
							<ul>
								<li>The difference is that setImmediate() allows IO-related callbacks to process first.</li>
								<li>process.nextTick() will prioritize your function before IO-related callbacks, possibly causing IO starvation</li>
							</ul>
						</li>
					</ul>
				</section>

				<section>
					<h2>Event Loop (5)</h2>
					<ul>
						<li>setTimeout() takes a second parameter that specifies how long to wait before the function is executed.</li>
						<li>setInterval() take a second parameter that specifies the interval at which this function should be executed.
							<ul>
								<li>If the interval is never turned off, the node program will execute "forever".</li>
							</ul>
						</li>
					</ul>
				</section>

				<section>
					<h2>Callback Hell (1)</h2>
					<p>Callbacks are great for asynchronous programming, but...</p>
					<p>It can lead to <em>callback hell</em>, where callbacks get indented</p>
				  <p><a href="images/callBackHell.png"><img height="518" src="images/callBackHell.png"></a></p>
				</section>

				<section>
					<h2>Callback Hell (2)</h2>
					<p>Here the callbacks have been highlighted...</p>
				  <p><a href="images/callBacksHighlighted.png"><img height="518" src="images/callBacksHighlighted.png"></a></p>
				</section>

				<section>
					<h2>Callback Hell (3)</h2>
					<ul>
						<li>The problem occurs when you have to chain multiple asynchronous calls together</li>
						<li>Each call in the chain has to be in a callback on the previous function
							<ul>
								<li>because you have to wait for the previous call to finish</li>
								<li>before you proceed</li>
							</ul>
						</li>
					</ul>
				</section>

				<section>
					<h2>Callback Hell (4)</h2>
					<ul>
						<li>Two ways to solve this problem:
							<ul>
								<li>Use synchronous functions instead
									<ul>
										<li>frowned upon by the Node community</li>
									</ul>
								</li>
								<li>Use named callback functions
									<ul>
										<li>Define your functions individually</li>
										<li>Then refer to them by name in the code that requires a callback</li>
									</ul>
								</li>
							</ul>
						</li>
					</ul>
				</section>

				<section>
					<h2>Callback Hell (5)</h2>
					<p>Fixing with Named Callbacks</p>
				  <p><a href="images/namedCallbacks.png"><img height="518" src="images/namedCallbacks.png"></a></p>
				</section>

				<section>
					<h2>Callback Hell (6)</h2>
					<p>Here the callbacks have been highlighted...</p>
				  <p><a href="images/namedCallbacksHighlighted.png"><img height="518" src="images/namedCallbacksHighlighted.png"></a></p>
				</section>

				<section>
					<h2>Just Callbacks?</h2>
					<ul>
						<li>Are callbacks the only asynchronous mechanism in Node?</li>
						<li>No!
							<ul>
								<li>Event Emitters</li>
								<li>Promises</li>
							</ul>
						</li>
						<li>We'll discuss these concepts next week</li>
					</ul>
				</section>

				<section>
					<h2>Node Execution Model (1)</h2>
					<ul>
						<li>For user-written code, Node is single threaded!</li>
						<li>Any code that you write is guaranteed to be synchronous</li>
						<li>You do not have to worry about race conditions</li>
						<li>IO is handled in parallel.</li>
					</ul>
				</section>

				<section>
					<h2>Node Execution Model (2)</h2>
					<ul>
						<li>If you issue an asyncrhonous call for IO
							<ul>
								<li>Your callback is registered</li>
								<li>The IO call is executed in a separate thread
									<ul>
										<li>Since it's an IO call, it immediately blocks</li>
									</ul>
								</li>
								<li>Other events on the event loop are handled as normal</li>
								<li>At some point, the IO completes and your callback is invoked
									<ul>
										<li>Invoked via setImmediate() or process.nextTick()</li>
										<li>So, even then, your code executes in a single thread</li>
									</ul>
								</li>
							</ul>
						</li>
					</ul>
				</section>

				<section>
					<h2>Node Execution Model (3)</h2>
					<ul>
						<li>This model makes it very easy to implement services that run server-side.</li>
						<li>You are guaranteed that only one method of your service is running at any one time.</li>
						<li>You are now in a position to understand the Javascript implementation of the Contacts web service</li>
					</ul>
				</section>

				<section>
					<h2>Hands-On Demo</h2>
					<ul>
						<li>Let's try a few things in class together</li>
						<li>Does everyone have Node installed?</li>
					</ul>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
